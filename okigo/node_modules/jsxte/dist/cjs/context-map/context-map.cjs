"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/context-map/context-map.ts
var context_map_exports = {};
__export(context_map_exports, {
  ContextDefinition: () => ContextDefinition,
  ContextMap: () => ContextMap,
  defineContext: () => defineContext
});
module.exports = __toCommonJS(context_map_exports);
var ContextMap = class {
  constructor(map = /* @__PURE__ */ new Map()) {
    this.map = map;
  }
  static create() {
    return new ContextMap();
  }
  static clone(original) {
    return new ContextMap(new Map(original.map));
  }
  /**
   * Retrieve the context data for the specified context. If the
   * context has never been set by any of this component
   * ancestors an error will be thrown.
   */
  get(ref) {
    const value = this.map.get(ref.id);
    if (value === void 0) {
      throw new Error(
        "Context not defined! Make sure the context is set before accessing it."
      );
    }
    return value;
  }
  /**
   * Partially update the state of the context data. Works only
   * for objects and can only be used if some context data is
   * already set beforehand.
   *
   * Updates to the context made with this method are only
   * visible to this component and it's descendants.
   */
  update(ref, updateData) {
    const data = this.get(ref);
    if (typeof data === "object" && data !== null && typeof updateData === "object" && updateData !== null) {
      if (Array.isArray(data)) {
        const arr = Array.from(data);
        for (const [key, value] of Object.entries(updateData)) {
          const index = Number(key);
          if (!isNaN(index))
            arr[index] = value;
        }
        return void this.map.set(ref.id, arr);
      } else {
        return void this.map.set(ref.id, { ...data, ...updateData });
      }
    } else {
      throw new Error(
        "Context data is not an object!. Partial updates are only possible for objects."
      );
    }
  }
  /**
   * Sets the context data for the specified context.
   *
   * Changes to the context made with this method are only
   * visible to this component and it's descendants.
   */
  set(ref, data) {
    this.map.set(ref.id, data);
  }
  /** Check if the context data for the specified context is set. */
  has(ref) {
    return this.map.has(ref.id);
  }
  /**
   * Replaces this context entries with the entries of the
   * context provided.
   *
   * @internal
   */
  replace(context) {
    this.map = context.map;
  }
};
var ContextDefinition = class {
  constructor() {
    this.id = Symbol();
  }
};
var defineContext = () => new ContextDefinition();
